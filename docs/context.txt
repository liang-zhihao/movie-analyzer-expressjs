 ```Act as a senior javascript developer, you are going to develop a backend application using Node, Express, node-MySQL2 , Swagger , Knex, JSON Web Tokens. Use ES6 with module
This is table format
create table movies.basics
(
    tconst               varchar(255)  not null,
    titleType            varchar(255)  not null,
    primaryTitle         varchar(255)  not null,
    originalTitle        varchar(255)  not null,
    year                 int           null,
    runtimeMinutes       int           null,
    genres               varchar(255)  not null,
    country              varchar(255)  null,
    poster               varchar(255)  null,
    plot                 text          null,
    rated                varchar(255)  null,
    boxoffice            int           null,
    imdbRating           decimal(3, 1) null,
    rottentomatoesRating decimal(3)    null,
    metacriticRating     decimal(3)    null,
    id                   int auto_increment
        primary key,
    constraint idx_tconst
        unique (tconst)
)
    collate = utf8mb4_unicode_ci;

create table movies.crew
(
    tconst    varchar(255) not null,
    directors varchar(255) not null,
    writers   varchar(255) not null,
    id        int auto_increment
        primary key
)
    collate = utf8mb4_unicode_ci;

create index idx_tconst
    on movies.crew (tconst);

create table movies.names
(
    nconst            varchar(255) not null,
    primaryName       varchar(255) not null,
    birthYear         int          null,
    deathYear         int          null,
    primaryProfession varchar(255) not null,
    knownForTitles    varchar(255) null,
    id                int auto_increment
        primary key
)
    collate = utf8mb4_unicode_ci;

create index idx_nconst
    on movies.names (nconst);

create table movies.principals
(
    tconst     varchar(255) not null,
    ordering   int          not null,
    nconst     varchar(255) not null,
    category   varchar(255) not null,
    job        varchar(255) not null,
    characters varchar(255) not null,
    id         int auto_increment
        primary key,
    name       varchar(255) null,
    movieName  varchar(255) null
)
    collate = utf8mb4_unicode_ci;

create index idx_tconst
    on movies.principals (tconst);

create table movies.ratings
(
    tconst varchar(255) not null,
    source varchar(255) not null,
    value  varchar(255) not null,
    id     int auto_increment
        primary key
)
    collate = utf8mb4_unicode_ci;

create index idx_tconst
    on movies.ratings (tconst);

create table movies.ratingsold
(
    tconst        varchar(255) not null,
    averageRating varchar(255) not null,
    numVotes      varchar(255) not null,
    id            int auto_increment
        primary key
)
    collate = utf8mb4_unicode_ci;

create index idx_tconst
    on movies.ratingsold (tconst);
```
Here is requirements:
```
All routes:

HTTP Request Route
GET /movies/search
This endpoint has three optional query 
parameters: title, year and page
 {
 "data": [
 { 
 "title": "Kate & Leopold", 
 "year": 2001, 
 "imdbID": "tt0035423", 
 "imdbRating": "6.4", 
 "rottenTomatoesRating": "52", 
 "metacriticRating": "44", 
 "classification": "PG-13"
 },
 { 
 "title": "The Other Side of the Wind", 
 "year": 2018, 
 "imdbID": "tt0069049", 
 "imdbRating": "6.7", 
 "rottenTomatoesRating": "83", 
 "metacriticRating": "78", 
 "classification": "R"
 },
 { 
 "title": "A Tale of Springtime", 
 "year": 1990, 
 "imdbID": "tt0097106", 
 "imdbRating": "7.1", 
 "rottenTomatoesRating": "86", 
 "metacriticRating": null, 
 "classification": "PG"
 }, 
 ],
 "pagination": {
 "total": 12184, 
 "lastPage": 122, 
 "prevPage": null, 
 "nextPage": 2, 
 "perPage": 100, 
 "currentPage": 1, 
 "from": 0, 
 "to": 100
 } 
} 
GET /movies/data/{imdbID}
{ 
 "year": 1998, 
 "runtime": 83, 
 "genres": [
 "Adventure", 
 "Animation", 
 "Comedy"
 ],
 "country": "United States", 
 "principals": [
 { 
 "id": "nm0506977", 
 "category": "producer", 
 "name": "Bradford Lewis", 
 "characters": []
 },
 { 
 "id": "nm0000095", 
 "category": "actor", 
 "name": "Woody Allen", 
 "characters": [
 "Z"
 ] 
 },
 
 ],
 "ratings": [
 { 
 "source": "Internet Movie Database", 
 "value": 6.5
 },
 { 
 "source": "Rotten Tomatoes", 
 "value": 92
 },
 
 ],
 "boxoffice": 90757863, 
 "poster": "https://m.mediaamazon.com/images/M/MV5BMzMzMDdlMDktODg4OC00Y2E5LTk1ZjMtNzM2MzIxZGQ0ZGI3XkEyXk
FqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg", 
 "plot": "A rather neurotic  ."
} 

GET /people/{id}
{ 
 "name": "Patrick Stewart", 
 "birthYear": 1940, 
 "deathYear": null, 
 "roles": [
 { 
 "movieName": "Star Trek: Generations", 
 "movieId": "tt0111280", 
 "category": "actor", 
 "characters": [
 "Picard"
 ],
 "imdbRating": 6.6
 },
 { 
 "movieName": "Star Trek: First Contact", 
 "movieId": "tt0117731", 
 "category": "actor", 
 "characters": [
 "Picard"
 ],
 "imdbRating": 7.6
 },
 { 
 "movieName": "Conspiracy Theory", 
 "movieId": "tt0118883", 
 "category": "actor", 
 "characters": [
 "Dr. Jonas"
 ],
 "imdbRating": 6.7
 },
 ] 
} 
Authentication endpoints 
HTTP Request Route
POST /user/register
POST /user/login
POST /user/refresh
POST /user/logout

The profile routes
You are required to, provide, in addition to the routes in the Assignment 2 API, two additional routes: 
GET /user/{email}/profile and PUT /user/{email}/profile. You need to implement these routes and 
add documentation to them to the Swagger file.
GET /user/{email}/profile
This route returns a user’s profile information as a JSON object. There are two different types of 
output presented here – one if the request is authorised, and the other if it is not. An unauthorised 
request (without an ‘Authorized:’ header) will receive an object like this:
200 OK
{
 "email": "mike@gmail.com",
 "firstName": "Michael",
 "lastName": "Jordan"
}
The same request, but with a valid JWT bearer token, will receive an object like this, with additional 
fields for date of birth and address.
200 OK
{
 "email": "mike@gmail.com",
 "firstName": "Michael",
 "lastName": "Jordan",
 "dob": "1963-02-17",
 "address": "123 Fake Street, Springfield"
}
The above two examples are of successful requests, which come with the HTTP status code of 200. 
However, if there is a problem with the JWT token, your server will return one of the following 
responses with a status code of 401 Unauthorized.
If the JWT token has expired:
401 Unauthorized
{
 "error": true,
 "message": "JWT token has expired"
}
If the JWT token failed verification:
401 Unauthorized
{
 "error": true,
 "message": "Invalid JWT token"
}
If there was an ‘Authorization:’ header, but it did not contain ‘Bearer ‘ followed by the JWT:
401 Unauthorized
{
 "error": true,
 "message": "Authorization header is malformed"
}
If {email} corresponds to a non-existent user, the following response will be returned with a status 
code of 404 Not Found:
404 Not Found
{
 "error": true,
 "message": "User not found"
}
Note that a newly created user will not have any of these fields filled in. Your server will return null 
for any fields that have not been provided, e.g.:
200 OK
{
 "email": "notmike@gmail.com",
 "firstName": null,
 "lastName": null,
 "dob": null,
 "address": null
}
PUT /user/{email}/profile
This is used to provide profile information. The request will contain a body with the application/json 
content-type containing profile fields in the same format that they are returned with GET 
/user/{email}/profile (except without the email address):
{
 "firstName": "Michael",
 "lastName": "Jordan",
 "dob": "1963-02-17",
 "address": "123 Fake Street, Springfield"
}
Users can only change their own profile information. In other words, if you are logged in as 
mike@gmail.com, you can change the profile of mike@gmail.com, but not any other user.
If you successfully update a profile, the response will be an object containing the updated profile:
200 OK
{
 "email": "mike@gmail.com",
 "firstName": "Michael",
 "lastName": "Jordan",
 "dob": "1963-02-17",
 "address": "123 Fake Street, Springfield"
}
If the user is logged in with the wrong email (that is, the JWT is provided and is valid, but the 
credentials do not belong to the user whose profile the user is attempting to modify) your server will 
return the following:
403 Forbidden
{
 "error": true,
 "message": "Forbidden"
}
If there is no Authorization: header:
401 Unauthorized
{
 "error": true,
 "message": "Authorization header ('Bearer token') not found"
}
If the JWT token has expired:
401 Unauthorized
{
 "error": true,
 "message": "JWT token has expired"
}
If the JWT token failed verification:
401 Unauthorized
{
 "error": true,
 "message": "Invalid JWT token"
}
If there was an ‘Authorization:’ header, but it did not contain ‘Bearer ‘ followed by the JWT:
401 Unauthorized
{
 "error": true,
 "message": "Authorization header is malformed"
}
If {email} corresponds to a non-existent user, the following response will be returned with a status 
code of 404 Not Found:
404 Not Found
{
 "error": true,
 "message": "User not found"
}
If the submitted object does not contain all of the fields:
400 Bad Request
{
 "error": true,
 "message": "Request body incomplete: firstName, lastName, dob and address 
are required"
}
If any of the fields are not strings:
400 Bad Request
{
 "error": true,
 "message": "Request body invalid: firstName, lastName, dob and address 
must be strings only"
}
If the date of birth is not a valid YYYY-MM-DD date (e.g. no April 31 or February 30, or February 29 on 
a non-leap year):
400 Bad Request
{
 "error": true,
 "message": "Invalid input: dob must be a real date in format YYYY-MM-DD"
}
The HTTP method used for this endpoint is PUT. PUT is a HTTP method similar to POST, though with 
different semantics. You can install express middleware for a PUT method with .put(), just as you 
use .post() to set up POST routes.
Your task is to implement both of these routes on the server, and also to modify the Swagger doc to 
document these routes, including all of the error codes.
Grade standards
We expect that you will follow a professional approach in the architecture and construction of the 
server. In particular:
• The routes and the overall structure are professional – logical and uncluttered, with 
appropriate use of specific routers mounted on the application
• There is appropriate use of middleware for managing components such as database 
connectivity and security
• There is appropriate error handling and the responses match those listed in the Swagger 
documentation (or in this specification, in the case of the profile routes)
• That the Swagger documentation has been amended to include both of the new profile 
routes and that the documentation matches the specification for these routes, as is 
documented in this file
• The application successfully serves the Swagger docs on the home page route
• The application is successfully deployed to a QUT VM using HTTPS with a self-signed 
certificate
• There is appropriate attention to application securit
```  
